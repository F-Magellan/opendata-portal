<?php
function od_rubric_menu_block_info() {
  return array(
    'block_rubric_menu' => array(
      'info' => t('Rubric menu'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

function render_rubric_term_submenu() {
  $render_info = array(
    'news' => array(
      'item_visibility_callback' => 'render_rubric_news_exists',
    ),
    'data' => array(
      'item_visibility_callback' => 'render_rubric_data_exists',
    ),
    'competitions' => array(
      'item_visibility_callback' => 'render_rubric_competitions_exists',
    ),
    'applications' => array(
      'item_visibility_callback' => 'render_rubric_applications_exists',
    ),
    'blogs' => array(
      'item_visibility_callback' => 'render_rubric_blogs_exists',
    ),
    'maps' => array(
      'item_visibility_callback' => 'render_rubric_maps_exists',
    ),

  );

  $build_menu = array(
    '#prefix' => '<ul>',
    '#suffix' => '</ul>',
  );

  $tree = taxonomy_get_tree(3); //rubrics
  foreach ($tree as $term) {
    $output = render_rubric_image($term);
    $output .= l(i18n_taxonomy_term_name($term), "taxonomy/term/{$term->tid}");
    $list_class = arg(2) == $term->tid? 'expanded' : 'collapsed';
    $build_menu[$term->tid] = array(
      '#prefix' =>  "<li class='$list_class'>",
      '#suffix' => '</li>',
    );
    $build_menu[$term->tid]['menu'] = array(
      '#markup' => $output,
    );
    $build_menu[$term->tid]['children'] = array(
      '#prefix' => '<ul>',
      '#suffix' => '</ul>',
    );
    foreach ($render_info as $submenu_key => $info) {
      if ($info['item_visibility_callback']($term)) {
        switch ($submenu_key) {
          case 'news':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. l(t('News'), "taxonomy/term/{$term->tid}/news") . '</li>';
            break;
          case 'data':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. '<a href="' . url('dataset') . '?f[0]=field_rubric%3A' . $term->tid  . '" rel="nofollow">' . t('Data') . '</a>'. '</li>';
            break;
          case 'competitions':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. l(t('Contests'), 'taxonomy/term/'. $term->tid . '/competition') . '</li>';
            break;
          case 'applications':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. l(t('Applications'), 'apps') . '</li>';
            break;
          case 'blogs':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. l(t('Blogs'), 'taxonomy/term/' . $term->tid . '/blogs') . '</li>';
            break;
          case 'maps':
            $build_menu[$term->tid]['children'][$submenu_key]['#markup'] = '<li>'. l(t('Map'), "taxonomy/term/{$term->tid}/map") . '</li>';
            break;
        }
      }
    }
  }

  return $build_menu;
}

function render_rubric_image($term) {
  $term_new = taxonomy_term_load($term->tid);
  $term_wrapper = entity_metadata_wrapper('taxonomy_term', $term_new);
  $output = '';
  if (isset($term_wrapper)) {
    try {
      //Check if we have image for this term
      if ($image = $term_wrapper->field_rubric_image->value()) {
        $output .= '<div class="menu-icon"><img src="' .  image_style_url('thumbnail', file_uri_target($image['uri'])) .  '"></div>';
      }
    }
    catch (EntityMetadataWrapperException $e) {
      //Silence
      //dpm($e);
    }
  }
  return $output;
}

function render_rubric_news_exists($term) {
  return TRUE;
}

function render_rubric_data_exists($term) {
  $query_datasets = new EntityFieldQuery;
  $result_datasets = $query_datasets->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'dataset')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_rubric', 'tid', $term->tid, '=')
    ->execute();
  if (count($result_datasets)) return TRUE;
}

function render_rubric_competitions_exists($term) {
  return TRUE;
}

function render_rubric_applications_exists($term) {
  $query = new EntityFieldQuery;
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'app')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_rubric', 'tid', $term->tid, '=')
    ->execute();
  if (count($result)) return TRUE;
}

function render_rubric_blogs_exists($term) {
  $query = new EntityFieldQuery;
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'blog')
    ->propertyCondition('status', 1)
    ->fieldCondition('field_rubric', 'tid', $term->tid, '=')
    ->execute(); //@fixme: Might be better to execute view here? or it's fine? View can be cached.
  if (count($result)) return TRUE;
}

function render_rubric_maps_exists($term) {
  if (render_rubric_data_exists($term)) return TRUE;
}

function od_rubric_menu_block_view($delta = '') {
  /*
   * @todo: Сделать небольшой рефакторинг кода
   * @fixme: Использовать темплейт крайне желательно
   * @fixme: Рендер этого блока можно сделать отдельной функцией, чтобы легко было переносить функционал в custom pane
   * @fixme: Ссылки забиты насильно руками. Было бы лучше достать их в каком-нибудь меню
   */
  $block = array();
  if ($delta != 'block_rubric_menu') {
    return;
  }
  $block['content'] = render(render_rubric_term_submenu());
  return $block;
}
