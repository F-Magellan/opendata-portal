<?php
/**
 * @file
 */

define('OD_DATASET_PATH', dirname(__FILE__));
define('OD_DATASET_DOWNLOAD_FIELD', 'field_resource_download');
define('OD_DATASET_DOWNLOAD_ROUTER_PATH', 'od_dataset_download_router');
define('OD_DATASET_ALIAS_DELIMITER', ':');
define('OD_DATASET_FIELD_LATEST_UPDATE', 'field_dataset_latest_update');

// Include our custom remote file source
require_once OD_DATASET_PATH. '/od_dataset.remote_file_source_mod.inc';

/**
 * Implements hook_menu()
 */
function od_dataset_menu() {
  $items = array();

  $items['dataset-actions/download_package/%node'] = array(
    'title' => '',
    'page callback' => 'od_dataset_download_package_page_callback',
    'page arguments' => array(2, 3),
    'access callback' => 'od_dataset_download_package_access_callback',
    'access arguments' => array(2, 3),
  );

  $items['dataset-actions/download_file/%file'] = array(
    'page callback' => 'od_dataset_download_file_page_callback',
    'page arguments' => array(2),
    'access callback' => 'od_dataset_download_file_access_callback',
    'access arguments' => array(2),
  );

  $arg_offset = count(explode('/', OD_DATASET_DOWNLOAD_ROUTER_PATH));
  $items[OD_DATASET_DOWNLOAD_ROUTER_PATH] = array(
    'page callback' => 'od_dataset_download_router_page_callback',
    'page arguments' => array($arg_offset + 1, $arg_offset + 2, $arg_offset + 3),
    'access callback' => 'od_dataset_download_router_access_callback',
    'access arguments' => array($arg_offset + 1, $arg_offset + 2, $arg_offset + 3),
  );

  return $items;
}

function od_dataset_download_router_page_callback($type, $nid, $rid) {
  return 'It\'s working!';
}

function od_dataset_download_router_access_callback($type, $nid, $rid) {
  return TRUE; //@todo: Access callback could be rewritten
}

/**
 * Gets a path for downloading resources from dataset.
 * @param $node_dataset
 * @param null $revision_id
 * @return string|bool
 *  A url for downloading something from dataset of FALSE in case of any error.
 *  Result of this should be passed to url() function in order to get valid URL
 */
function od_dataset_download_path($node_dataset, $revision_id = NULL) {
  // Change download callback to od_dataset's callback to support encodings
  //$download_uri = 'dataset-actions/download_file/'. $item['fid'];
  $download_uri = 'not_implemented_yet/stay_cool/it_will_be_ok';
  try {
    $wrapper = od_dataset_get_wrapper($node_dataset, $revision_id);
    if ($wrapper->field_multivolume->raw() == TRUE) {
      $download_uri = 'dataset-actions/download_package/' . $node_dataset->nid->value();
    }
  }
  catch (Exception $e) {
    // @fixme: prevent errors here.
    watchdog_exception('od_common', $e);
    //throw $e;

    $download_uri = FALSE;
  }

  return $download_uri;
}

/**
 * Gets a path for downloading resources from dataset.
 * @param $node_dataset
 * @param null $revision_id
 * @return string|bool
 *  A url for downloading something from dataset of FALSE in case of any error.
 *  Result of this should be passed to url() function in order to get valid URL
 */
function od_dataset_download_structure_path($node_dataset, $revision_id = NULL) {
  // Change download callback to od_dataset's callback to support encodings
  //$download_uri = 'dataset-actions/download_file/'. $item['fid'];
  $download_uri = 'not_implemented_yet/stay_cool/it_will_be_ok';
  try {
    $wrapper = od_dataset_get_wrapper($node_dataset, $revision_id);
    if ($wrapper->field_multivolume->raw() == TRUE) {
      $download_uri = 'dataset-actions/download_package/' . $node_dataset->nid->value();
    }
  }
  catch (Exception $e) {
    // @fixme: prevent errors here.
    watchdog_exception('od_common', $e);
    //throw $e;

    $download_uri = FALSE;
  }

  return $download_uri;
}

/**
 * @param $nid
 * @return bool|mixed
 */
function od_dataset_download_package_access_callback($node, $revision_id = NULL) {
  $wrapper = od_dataset_get_wrapper($node, $revision_id);

  //@todo add other access checks
  if (!$wrapper || $wrapper->{'type'}->value() != 'dataset' || $wrapper->field_resources->count() == 0) {
    return FALSE;
  }

  return TRUE;
}

function od_dataset_download_file_access_callback($file) {
  return TRUE;
}

/**
 * Gets wrapper for a node with specific revision.
 * @param $node_or_nid
 * @param null $revision_id
 * @return bool|EntityMetadataWrapper
 */
function od_dataset_get_wrapper($node_or_nid, $revision_id = NULL) {
  $obj = $node_or_nid;
  $nid = is_object($node_or_nid) && isset($node_or_nid->nid) ? $node_or_nid->nid : $node_or_nid;
  if ($revision_id !== NULL && ($obj = node_load($nid, $revision_id)) && !$obj) {
    return FALSE;
  }

  return entity_metadata_wrapper('node', $obj);
}

/**
 * Page callback for downloading zip file.
 */
function od_dataset_download_package_page_callback($node, $revision_id = NULL) {
  od_common_module('core');
  $target_encoding = isset($_GET['encoding']) ? $_GET['encoding'] : NULL;
  $wrapper = od_dataset_get_wrapper($node, $revision_id);
  $resources = $wrapper->field_resources;

  $zip = new ZipArchive();
  $tmp_file = tempnam(sys_get_temp_dir(), 'tmp');
  if ( true !== ($zip->open($tmp_file, ZIPARCHIVE::CREATE | ZIPARCHIVE::OVERWRITE) )) {
    drupal_not_found(); //@fixme: Control somehow. Write to watchdog.
  }

  $detector = od_detect_encoding_get_detector();
  $resource_index = 1;
  foreach ($resources as $resource) {
    if ($file = $resource->field_upload->value()) {
      $ext = pathinfo($file->uri, PATHINFO_EXTENSION);
      $suffix = $ext ? '.' . $ext : NULL;

      $tmp_wrapper = file_stream_wrapper_get_instance_by_scheme('temporary');
      $out_file = od_common_tmpfilename($tmp_wrapper->realpath(), $file->uri);
      $realpath = file_stream_wrapper_get_instance_by_uri($file->uri)->realpath();
      if (file_exists($file->uri)) {
        $add_file = $realpath;
        if ($target_encoding && $detector->convertFile($file->uri, $out_file, $target_encoding)) {
          $add_file = $out_file;
        }

        $zip->addFile($add_file, "resource_{$resource_index}{$suffix}");
      }
    }

    $resource_index++;
  }

  if (!$zip->close()) {
    @unlink($tmp_file);
    drupal_not_found();
  }

  od_dataset_download_file($tmp_file, drupal_substr($wrapper->title->value(), 0, 200). '.zip');
  drupal_exit();
}

function od_dataset_download_file_page_callback($file) {
  $target_encoding = isset($_GET['encoding']) ? $_GET['encoding'] : NULL;
  if ($target_encoding) {
    od_common_module('core');
    $detector = od_detect_encoding_get_detector();
    $out_file = od_common_tmpfilename('temporary://', $file->uri);
    // @fixme: Check if encoding is valid before converting
    if ($detector->convertFile($file->uri, $out_file, $target_encoding)) {
      od_dataset_download_file($out_file, $file->filename);
      drupal_exit();
    }
  }
  else {
    od_dataset_download_file($file->uri, $file->filename);
    drupal_exit();
  }

  drupal_not_found();
}

function od_dataset_download_file($path, $filename = NULL) {
  $filename = !$filename ? pathinfo($path, PATHINFO_FILENAME) : $filename;
  ob_clean();
  drupal_add_http_header('Content-Type', 'octet/stream');
  drupal_add_http_header('Content-Disposition', 'attachment; filename='. $filename);
  drupal_add_http_header('Content-Transfer-Encoding', 'Binary');
  drupal_add_http_header('Content-Description', 'File Transfer');
  drupal_add_http_header('Content-Length', filesize($path));
  readfile($path);
  @unlink($path);
}

function od_dataset_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'od_dataset') . '/views',
  );
}

function od_dataset_save_aliases($node_or_nid, $revision_id = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    foreach ($wrapper->{OD_DATASET_DOWNLOAD_FIELD} as $_val_wr) {
      list($type, $alias) = od_dataset_alias_parse($_val_wr->value());
      $path = array(
        'source' => OD_DATASET_DOWNLOAD_ROUTER_PATH. "/{$type}/{$wrapper->nid->value()}",
        'alias' => $alias,
      );

      path_save($path);
    }
  }
}

function od_dataset_set_alias_links($node_or_nid, $revision_id = NULL) {
  if(($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) && ($links = od_dataset_build_alias_links($node_or_nid, $revision_id))) {
    $wrapper->{OD_DATASET_DOWNLOAD_FIELD}->set(array());
    foreach ($links as $link) {
      $wrapper->{OD_DATASET_DOWNLOAD_FIELD}[] = $link;
    }

    return TRUE;
  }

  return FALSE;
}

function od_dataset_build_alias_links($node_or_nid, $revision_id = NULL) {
  $links = FALSE;
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $alias = drupal_get_path_alias("node/{$wrapper->nid->value()}");
    $stamp = gmdate('Y-m-d\TH-i', od_dataset_last_update_time($node_or_nid, $revision_id));
    //$format = $wrapper->field_resources->get(0)->field_format->name->value();
    $format = od_dataset_get_format($node_or_nid, $revision_id);
    $suffix = $format ? '.' . $format : '';
    $links = array(
      'data' => od_dataset_alias_build('data', "{$alias}/data-{$stamp}-structure-{$stamp}{$suffix}"),
      'structure' => od_dataset_alias_build('structure', "{$alias}/structure-{$stamp}{$suffix}"),
    );
  }

  return $links;
}

/**
 * @param $node_or_nid
 * @param null $revision_id
 * @return string
 * @fixme: Implement this
 */
function od_dataset_get_format($node_or_nid, $revision_id = NULL) {
  return 'csv';
}

function od_dataset_entity_insert($entity, $type) {
  //od_dataset_entity_update($entity, $type);
}

function od_dataset_entity_presave($entity, $type) {
  if ($type == 'node' && isset($entity->type) && $entity->type == 'dataset') {
    od_dataset_set_alias_links($entity);
    od_dataset_save_aliases($entity);
  }
}

function od_dataset_alias_parse($alias) {
  return explode(OD_DATASET_ALIAS_DELIMITER, $alias);
}

function od_dataset_alias_build($type, $alias) {
  return ($type . OD_DATASET_ALIAS_DELIMITER . $alias);
}

function od_dataset_last_update_time($node_or_nid, $revision_id = NULL, $newtime = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $stamp = $wrapper->{OD_DATASET_FIELD_LATEST_UPDATE}->value();
    $newtime = ($newtime === NULL && $stamp === FALSE) ? $wrapper->changed->value() ? $newtime;
    if ($newtime !== NULL) {
      $wrapper->{OD_DATASET_FIELD_LATEST_UPDATE}->set($newtime);
      $stamp = $newtime;
    }

    return $stamp;
  }

  return FALSE;
}