<?php
/**
 * @file
 * @todo: Use pathauto?
 */

define('OD_DATASET_PATH', dirname(__FILE__));
define('OD_DATASET_DOWNLOAD_ROUTER_PATH', 'od_dataset_download_router');
define('OD_DATASET_ALIAS_DELIMITER', ':');
/*
 * Fields
 */
define('OD_DATASET_DOWNLOAD_FIELD', 'field_resource_download');
define('OD_DATASET_FIELD_LATEST_UPDATE_DATASET', 'field_dataset_latest_update');
define('OD_DATASET_FIELD_LATEST_UPDATE', OD_DATASET_FIELD_LATEST_UPDATE_DATASET); //@deprecated. Fallback
define('OD_DATASET_FIELD_LATEST_UPDATE_STRUCTURE', 'field_structure_latest_update');

// Include our custom remote file source
require_once OD_DATASET_PATH. '/od_dataset.remote_file_source_mod.inc';

/**
 * Implements hook_menu()
 */
function od_dataset_menu() {
  $items = array();

  $items['dataset-actions/download_package/%node'] = array(
    'title' => '',
    'page callback' => 'od_dataset_download_package_page_callback',
    'page arguments' => array(2, 3),
    'access callback' => 'od_dataset_download_package_access_callback',
    'access arguments' => array(2, 3),
  );

  $items['dataset-actions/download_file/%file'] = array(
    'page callback' => 'od_dataset_download_file_page_callback',
    'page arguments' => array(2),
    'access callback' => 'od_dataset_download_file_access_callback',
    'access arguments' => array(2),
  );

  $arg_offset = count(explode('/', OD_DATASET_DOWNLOAD_ROUTER_PATH));
  $items[OD_DATASET_DOWNLOAD_ROUTER_PATH. '/%/%'] = array(
    'page callback' => 'od_dataset_download_router_page_callback',
    'page arguments' => array($arg_offset + 0, $arg_offset + 1, $arg_offset + 2),
    'access callback' => 'od_dataset_download_router_access_callback',
    'access arguments' => array($arg_offset + 0, $arg_offset + 1, $arg_offset + 2),
  );

  $items['od_dataset_batch_update'] = array(
    'page callback' => 'od_dataset_batch_update_page_callback',
    'access arguments' => array('administer'),
    'title' => 'batch',
  );

  return $items;
}

function od_dataset_download_router_page_callback($type, $nid, $rid = NULL) {
  switch ($type) {
    case 'structure':
    case 'data':
      if (!empty($rid) || (($alias = drupal_lookup_path('alias', $_GET['q'])) && ($rid = od_dataset_get_revision_id_by_alias($alias, $type)))) {
        if (od_dataset_do_download($nid, $rid, $type)) {
          // Go to download, all is ok
          drupal_exit();
        }

        // Otherwise just show 404 page
      }
      break;
  }

  watchdog('od_dataset', 'Fake download :plac', array(':plac' => $_GET['q']), WATCHDOG_EMERGENCY);
  drupal_not_found();
}

/**
 * @param $alias
 * @param string $type
 * @return bool
 * @throws Exception
 * @todo: Add static (non-static?) cache
 */
function od_dataset_get_revision_id_by_alias($alias, $type = '%') {
  $revision_id = FALSE;
  if ($info = field_info_field(OD_DATASET_DOWNLOAD_FIELD)) {
    if ($info['storage']['type'] != 'field_sql_storage') {
      throw new Exception("Storage type of a ". OD_DATASET_DOWNLOAD_FIELD. ' should be field_sql_storage! Or implement another...');
    }

    list($table, $column_info) = each($info['storage']['details']['sql']['FIELD_LOAD_REVISION']);
    $operator = $type == '%' ? ' LIKE ' : '=';
    $sql = "
    SELECT
      revision_id
    FROM
      {{$table}} f
    INNER JOIN {node_revision} nr ON nr.vid=f.revision_id
    WHERE (
      f.{$column_info['value']}{$operator}:field_value
    )
    ORDER BY
      f.revision_id DESC
    LIMIT 1
    ";

    $result = db_query($sql, array(':field_value' => "{$type}:{$alias}"));
    if ($tmp = $result->fetchField()) {
      $revision_id = $tmp;
    }
  }

  return $revision_id;
}

function od_dataset_do_download($node_or_nid, $revision_id = NULL, $type = 'data') {
  try {
    $wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id);
    if (!$wrapper) {
      throw new Exception('Can\'t get dataset wrapper');
    }

    if ($wrapper->field_resources->count() == 0) {
      return FALSE; // just exit from function and let parent function to end up with drupal_not_found();
    }

    $download_links = array();
    foreach ($wrapper->{OD_DATASET_DOWNLOAD_FIELD} as $vw) {
      list ($_type, $alias, ) = od_dataset_alias_parse($vw->value());
      $download_links[$_type] = pathinfo($alias, PATHINFO_BASENAME);
    }

    switch ($type) {
      case 'data':
        if ((boolean) $wrapper->field_multivolume->value() === TRUE) {
          return od_dataset_download_package_page_callback($wrapper, $download_links[$type]);
        }
        elseif ($file = $wrapper->field_resources->get(0)->field_upload->value()) {
          return od_dataset_download_file_page_callback($file, $download_links[$type]);
        }
        break;
      case 'structure':
        if ($file = $wrapper->field_resources->get(0)->field_upload_structure->value()) {
          return od_dataset_download_file_page_callback($file, $download_links[$type]);
        }
        break;
    }

    return TRUE;
  }
  catch (Exception $e) {
    watchdog_exception('od_dataset', $e);
    return FALSE;
  }
}

function od_dataset_download_router_access_callback($type, $nid, $rid) {
  return TRUE; //@todo: Access callback could be rewritten
}

/**
 * Gets a path for downloading resources from dataset.
 * @param $node_dataset
 * @param null $revision_id
 * @return ODDatasetDownloadUriObject
 *  A url for downloading something from dataset of FALSE in case of any error.
 *  Result of this should be passed to url() function in order to get valid URL
 */
function od_dataset_download_path($node_dataset, $revision_id = NULL, $target_type = 'data') {
  // Change download callback to od_dataset's callback to support encodings
  //$download_uri = 'dataset-actions/download_file/'. $item['fid'];
  $result = new ODDatasetDownloadUriObject();
  try {
    $wrapper = od_dataset_get_wrapper($node_dataset, $revision_id);
    if ($wrapper->field_resources->count() > 0 && ($resource = $wrapper->field_resources[0]) && ($resource->value())) {
      // Check external link first
      if (($target_type == 'data' && ($remote_link = $resource->field_link_remote_file->value())) || ($target_type == 'structure' && ($remote_link = $resource->field_link_structure_file->value()))) {
        $result->data($remote_link['uri']);
        $result->type(ODDatasetDownloadUriObject::LINK_EXTERNAL);
      }
      elseif ($target_type == 'data' && ($api_link = $resource->field_link_api->value()) && ($parsed = parse_url($api_link['url']))) {
//        $build = $parsed;
//        $build['scheme'] = !empty($build['scheme']) ? $build['scheme']. '://' : 'http://';
//        $build['host'] = !empty($build['host']) ? $build['host'] : $_SERVER['HTTP_HOST'];
//        $build['path'] = !empty($build['path']) ? '/'. $build['path'] : '';
//
//        $api_link['attributes'] += array('absolute')
//        $url_built = url("{$build['scheme']}{$build['host']}{$build['path']}", $api_link['attributes']); //@fixme: Check attributes' behaviour
        $url_built = url($api_link['url'], $api_link['attributes']);
        $result->data($url_built);
        $result->type(ODDatasetDownloadUriObject::LINK_EXTERNAL);
      }
      else {
        // Fallback to internal
        $result->data(od_dataset_download_path_internal($node_dataset, $revision_id, $target_type));
        $result->type(ODDatasetDownloadUriObject::LINK_INTERNAL);
      }
    }

    if ($result->exists() && $result->type() == ODDatasetDownloadUriObject::LINK_INTERNAL && !drupal_lookup_path('source', $result->data())) {
      $result->invalidate(); // Source doesn't exist. Orphaned alias.
    }
  }
  catch (Exception $e) {
    // @fixme: prevent errors here.
    watchdog_exception('od_common', $e);
    $result->invalidate();
  }

  return $result;
}

/**
 * Gets a path for downloading resources from dataset.
 * @param $node_dataset
 * @param null $revision_id
 * @return string|bool
 *  A url for downloading something from dataset of FALSE in case of any error.
 *  Result of this should be passed to url() function in order to get valid URL
 * @fixme: Check if files are exist
 */
function od_dataset_download_path_internal($node_dataset, $revision_id = NULL, $target_type = 'data') {
  // Change download callback to od_dataset's callback to support encodings
  //$download_uri = 'dataset-actions/download_file/'. $item['fid'];
  $download_uri = FALSE;
  try {
    $wrapper = od_dataset_get_wrapper($node_dataset, $revision_id);
    if ($wrapper->field_resources->count() > 0) {
      $exists = FALSE;
      // Firstly check if we have any data in fact
      switch ($target_type) {
        case 'data':
          $exists = $wrapper->field_resources[0]->field_upload->value() ? TRUE : FALSE;
          break;
        case 'structure':
          $exists = $wrapper->field_resources[0]->field_upload_structure->value() ? TRUE : FALSE;
          break;
      }

      if ($exists) {
        foreach($wrapper->{OD_DATASET_DOWNLOAD_FIELD} as $_val_wr) {
          list($type, $alias) = od_dataset_alias_parse($_val_wr->value());
          if ($target_type == $type) {
            $download_uri = $alias;
            break;
          }
        }
      }
    }
  }
  catch (Exception $e) {
    // @fixme: prevent errors here.
    watchdog_exception('od_common', $e);
    $download_uri = FALSE;
  }

  return $download_uri;
}

/**
 * Gets a path for downloading resources from dataset.
 * @param $node_dataset
 * @param null $revision_id
 * @return string|bool
 *  A url for downloading something from dataset of FALSE in case of any error.
 *  Result of this should be passed to url() function in order to get valid URL
 * @deprecated
 */
function od_dataset_download_structure_path($node_dataset, $revision_id = NULL) {
  return od_dataset_download_path($node_dataset, $revision_id, 'structure');
}

/**
 * @param $nid
 * @return bool|mixed
 */
function od_dataset_download_package_access_callback($node, $revision_id = NULL) {
  $wrapper = od_dataset_get_wrapper($node, $revision_id);

  //@todo add other access checks
  if (!$wrapper || $wrapper->{'type'}->value() != 'dataset' || $wrapper->field_resources->count() == 0) {
    return FALSE;
  }

  return TRUE;
}

function od_dataset_download_file_access_callback($file) {
  return TRUE;
}

/**
 * Gets wrapper for a node with specific revision.
 * @param $node_or_nid
 * @param null $revision_id
 * @return bool|EntityMetadataWrapper
 */
function od_dataset_get_wrapper($node_or_nid, $revision_id = NULL) {
  if ($node_or_nid instanceof EntityMetadataWrapper) {
    if ($revision_id !== NULL && $node_or_nid->vid->value() != $revision_id) {
      return od_dataset_get_wrapper($node_or_nid->nid->value(), $revision_id);
    }

    return $node_or_nid;
  }

  $obj = $node_or_nid;
  $nid = is_object($node_or_nid) && isset($node_or_nid->nid) ? $node_or_nid->nid : $node_or_nid;
  if (($revision_id !== NULL && ($obj = node_load($nid, $revision_id)) && !$obj) || !$obj) {
    return FALSE;
  }

  return entity_metadata_wrapper('node', $obj);
}

/**
 * @param $node_or_nid
 * @param null $revision_id
 * @return bool
 */
function od_dataset_get_wrapper_by_resource($node_or_nid, $revision_id = NULL) {
  if (($resource = od_dataset_get_wrapper($node_or_nid)) && $resource->getBundle() == 'resource') {
    return od_dataset_get_wrapper($resource->field_dataset_ref); //@fixme: Get with proper revision id
  }

  return FALSE;
}

/**
 * Page callback for downloading zip file.
 */
function od_dataset_download_package_page_callback($node, $revision_id = NULL, $filename = NULL) {
  od_common_module('core');
  $target_encoding = isset($_GET['encoding']) ? $_GET['encoding'] : NULL;
  $wrapper = od_dataset_get_wrapper($node, $revision_id);
  $resources = $wrapper->field_resources;

  $zip = new ZipArchive();
  $tmp_file = od_common_tmpfilename('temporary:/', REQUEST_TIME, TRUE); // Create file, of course!
  $tmp_file = file_stream_wrapper_get_instance_by_uri($tmp_file)->realpath();
  if ( true !== ($zip->open($tmp_file, ZIPARCHIVE::CREATE | ZIPARCHIVE::OVERWRITE) )) {
    return FALSE;
  }

  od_common_module('file');
  // Create file that will expire in 6 hours
  $drupal_file = od_common_file_save_data_by_path($tmp_file, 'temporary://', FILE_EXISTS_RENAME, TRUE);
  @unlink($tmp_file); // Remove old file if it existed

  if (!$drupal_file) {
    return FALSE; // Can't operate further, we have an error. Disaster!
  }

  $detector = od_detect_encoding_get_detector();
  $resource_index = 1;
  foreach ($resources as $resource) {
    if ($file = $resource->field_upload->value()) {
      $ext = pathinfo($file->uri, PATHINFO_EXTENSION);
      $suffix = $ext ? '.' . $ext : NULL;

      $tmp_wrapper = file_stream_wrapper_get_instance_by_scheme('temporary');
      $out_file = od_common_tmpfilename($tmp_wrapper->realpath(), $file->uri);
      $realpath = file_stream_wrapper_get_instance_by_uri($file->uri)->realpath();
      if (file_exists($file->uri)) {
        $add_file = $realpath;
        if ($target_encoding && $detector->convertFileAdvanced($file->uri, $out_file, $target_encoding)) {
          $add_file = $out_file;
        }

        // Handle expirations. File will be created with status=0 but we don't need it anymore in further code.
        if ($df = od_common_file_save_data_by_path($add_file, 'temporary://', FILE_EXISTS_RENAME, TRUE)) {
          // Clean orphaned files
          @unlink($out_file);
          @unlink($realpath);

          $rp = file_stream_wrapper_get_instance_by_uri($df->uri)->realpath();
          $zip->addFile($rp, "resource_{$resource_index}{$suffix}");
        }
      }
    }

    $resource_index++;
  }

  if (!($zip->close() && $zip->numFiles > 0)) {
    return FALSE;
  }

  $filename = $filename === NULL ? drupal_substr($wrapper->title->value(), 0, 200). '.zip' : $filename;
  return od_dataset_download_file_page_callback($drupal_file, $filename, TRUE);
}

function od_dataset_download_file_page_callback($file, $filename = NULL, $skip_converting = FALSE) {
  $file = (object) $file;
  $filename = $filename !== NULL ? $filename : $file->filename;
  $target_encoding = isset($_GET['encoding']) ? $_GET['encoding'] : NULL;
  if (!$skip_converting && $target_encoding) {
    od_common_module('core');
    od_common_module('file');
    $detector = od_detect_encoding_get_detector();
    $out_file = od_common_tmpfilename('temporary:/', $file->uri);
    // @fixme: Check if encoding is valid before converting
    if ($detector->convertFileAdvanced($file->uri, $out_file, $target_encoding)) {
      if ($drupal_file = od_common_file_save_data_by_path($out_file, 'temporary://', FILE_EXISTS_RENAME, TRUE)) {
        od_dataset_download_file($drupal_file->uri, $filename);
        return TRUE;
      }
    }
  }
  else {
    od_dataset_download_file($file->uri, $filename);
    return TRUE;
  }

  return FALSE;
}

function od_dataset_download_file($path, $filename = NULL) {
  $filename = !$filename ? pathinfo($path, PATHINFO_FILENAME) : $filename;
  ob_clean();
  drupal_add_http_header('Content-Type', 'octet/stream');
  drupal_add_http_header('Content-Disposition', 'attachment; filename='. $filename);
  drupal_add_http_header('Content-Transfer-Encoding', 'Binary');
  drupal_add_http_header('Content-Description', 'File Transfer');
  drupal_add_http_header('Content-Length', filesize($path));
  readfile($path);
}

function od_dataset_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'od_dataset') . '/views',
  );
}

function od_dataset_save_aliases($node_or_nid, $revision_id = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    foreach ($wrapper->{OD_DATASET_DOWNLOAD_FIELD} as $_val_wr) {
      list($type, $alias, $vid) = od_dataset_alias_parse($_val_wr->value());
      $path = array(
        'source' => OD_DATASET_DOWNLOAD_ROUTER_PATH. "/{$type}/{$wrapper->nid->value()}/{$vid}",
        'alias' => $alias,
      );

      if (!($oldpath = path_load(array('alias' => $alias))) || ($oldpath['source'] != $path['source'])) {
        path_save($path);
        // Save to history
        db_insert('od_dataset_paths')
          ->fields(array(
            'entity_type' => $wrapper->type(),
            'entity_id' => $wrapper->nid->value(),
            'revision_id' => $wrapper->{$wrapper->entityKey('revision')}->value(),
            'pid' => $path['pid'],
          ))
          ->execute();
      }
    }

    $fields_to_update = array(
      OD_DATASET_DOWNLOAD_FIELD => array(),
      OD_DATASET_FIELD_LATEST_UPDATE_DATASET => array(),
      OD_DATASET_FIELD_LATEST_UPDATE_STRUCTURE => array(),
    );

    $wrapper->value()->revision = 0;
    od_dataset_save_important_fields($wrapper, NULL, $fields_to_update);
  }
}

function od_dataset_save_important_fields($node_or_nid, $revision_id = NULL, $fields = NULL) {
  $wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id);
  if (!$wrapper) {
    throw new Exception('Can\'t get dataset wrapper');
  }

  if (empty($fields)) {
    return FALSE;
  }
//data:7710349494-mfclist/data-20140326T1245-structure-20140326T1245.csv 5126
  $entity = $wrapper->value();
  $entity_type = $wrapper->type();
  // Collect the storage backends used by the remaining fields in the entities.
  $storages = array();
  foreach ($fields as $_fieldname => $_meta) {
    $instance = field_info_instance($entity_type, $_fieldname, $wrapper->getBundle());
    $field = field_info_field_by_id($instance['field_id']);
    $field_id = $field['id'];
    $field_name = $field['field_name'];
    // Leave the field untouched if $entity comes with no $field_name property,
    // but empty the field if it comes as a NULL value or an empty array.
    // Function property_exists() is slower, so we catch the more frequent
    // cases where it's an empty array with the faster isset().
    if (isset($entity->$field_name) || property_exists($entity, $field_name)) {
      // Collect the storage backend if the field has not been written yet.
      if (!isset($skip_fields[$field_id])) {
        $storages[$field['storage']['type']][$field_id] = $field_id;
      }
    }
  }

  // Field storage backends save any remaining unsaved fields.
  foreach ($storages as $storage => $fields) {
    $storage_info = field_info_storage_types($storage);
    module_invoke($storage_info['module'], 'field_storage_write', $entity_type, $entity, FIELD_STORAGE_UPDATE, $fields);
  }

  // Clear field caches
  $entity_info = $wrapper->entityInfo();
  if ($entity_info['field cache']) {
    cache_clear_all("field:$entity_type:{$wrapper->getIdentifier()}", 'cache_field');
  }
}

function od_dataset_set_alias_links($node_or_nid, $revision_id = NULL) {
  if(($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) && ($links = od_dataset_build_alias_links($node_or_nid, $revision_id))) {
    $wrapper->{OD_DATASET_DOWNLOAD_FIELD}->set(array());
    foreach ($links as $link) {
      $wrapper->{OD_DATASET_DOWNLOAD_FIELD}[] = $link;
    }

    return TRUE;
  }

  return FALSE;
}

function od_dataset_build_alias_links($node_or_nid, $revision_id = NULL) {
  $links = FALSE;
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $alias = drupal_get_path_alias("node/{$wrapper->nid->value()}");
    //$format = $wrapper->field_resources->get(0)->field_format->name->value();
    $format = od_dataset_get_format($node_or_nid, $revision_id);
    $suffix = $format ? '.' . $format : '';

    $structure_format = 'csv';
    if ($wrapper->field_resources->count() > 0 && $wrapper->field_resources->get(0)->getBundle() == 'resource') {
      if (($file = $wrapper->field_resources->get(0)->field_upload_structure->value()) && ($ext = pathinfo($file->uri, PATHINFO_EXTENSION))) {
        $structure_format = $ext;
      }
    }

    $links = array();
    $offset = 0;
    do {
      $ts_data = od_dataset_last_update_time($node_or_nid, $revision_id, 'data') + $offset;
      $ts_structure = od_dataset_last_update_time($node_or_nid, $revision_id, 'structure') + $offset;
      $stamp_data = gmdate('Ymd\THi', $ts_data);
      $stamp_structure = gmdate('Ymd\THi', $ts_structure);

      $data_alias = "{$alias}/data-{$stamp_data}-structure-{$stamp_structure}{$suffix}";
      $structure_alias = "{$alias}/structure-{$stamp_structure}.{$structure_format}";

      $paths_exist = path_load(array('alias' => $data_alias)) | path_load(array('alias' => $structure_alias));
      if ($offset > 0) {
        $a = 1;
      }
    }
    while ($paths_exist !== 0 && $offset+=60);
    //@todo: Control data availability somewhere else not here

    od_dataset_last_update_time($node_or_nid, $revision_id, 'data', $ts_data);
    od_dataset_last_update_time($node_or_nid, $revision_id, 'structure', $ts_structure);
    $links['data'] = od_dataset_alias_build('data', $data_alias, $wrapper->vid->value());
    $links['structure'] = od_dataset_alias_build('structure', $structure_alias, $wrapper->vid->value());
  }

  return $links;
}

/**
 * @param $node_or_nid
 * @param null $revision_id
 * @return string
 * @fixme: Implement this
 */
function od_dataset_get_format($node_or_nid, $revision_id = NULL) {
  $extension = FALSE;
  if (($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) && $wrapper->field_resources->count() > 0) {
    try {
      if ((boolean) $wrapper->field_multivolume->value() === TRUE) {
        $extension = 'zip';
      }
      elseif ($_tmp_term = $wrapper->field_resources->get(0)->field_format->value()) {
        $extension = $_tmp_term->name;
      }
    }
    catch (Exception $e) {
      watchdog_exception('od_dataset', $e);
    }
  }

  return $extension;
}

function od_dataset_entity_insert($entity, $type) {
  od_dataset_on_entity_save($entity, $type, 'insert');
}

function od_dataset_entity_update($entity, $type) {
  od_dataset_on_entity_save($entity, $type, 'update');
}

function od_dataset_on_entity_save($entity, $type, $operation) {
  if ($type == 'node' && isset($entity->type) && $entity->type == 'dataset') {
    od_dataset_set_alias_links($entity);
    od_dataset_save_aliases($entity);
  }
  //@fixme:  Should work on this better
//  elseif ($operation == 'update' && $type == 'node' && isset($entity->type) && $entity->type == 'resource') {
//    static $processed = array();
//    $items = field_get_items($type, $entity, 'field_dataset_ref');
//    if (($item = reset($items)) && !isset($processed[$item['target_id']])) {
//      $processed[$item['target_id']] = TRUE;
//      od_dataset_cascade_update_prepare($item['target_id'], $item['revision_id'], $entity); // Prepare resource
//      od_dataset_cascade_update_dataset($item['target_id'], $item['revision_id']); // And update it immediately
//    }
//  }
  //@fixme: Do we need to auto update it in that way?
//  elseif ($type = 'node' && isset($entity->type) && $entity->type == 'resource') {
//    $dataset_wr = od_dataset_get_wrapper_by_resource($entity->nid);
//    od_dataset_last_update_time($dataset_wr, NULL, 'data', time());
//  }
}

function od_dataset_cascade_update_prepare($nid, $vid, $resource) {
  if (($rw = od_dataset_get_wrapper($resource))) {
    $storage = &drupal_static(__FUNCTION__. ":{$nid}:{$vid}", array());
    $storage[$rw->nid->value()] = $rw;
  }
}

function od_dataset_cascade_update_dataset($node_or_nid, $revision_id = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $storage = &drupal_static("od_dataset_cascade_update_prepare:{$wrapper->nid->value()}:{$wrapper->vid->value()}", array());

    $new_resources = array();
    if (count($storage) > 0) {
      $wrapper->value()->revision = 1; // Create new revision
      $wrapper->save();
      // Reinit wrapper
      $wrapper = entity_metadata_wrapper('node', $wrapper->value());
      $wrapper->value()->revision = 0;
      foreach ($wrapper->field_resources as $rw) {
        //$rw->value()->original = $rw->value();

        if (isset($storage[$rw->nid->value()])) {
          $w = $storage[$rw->nid->value()];
          unset($storage[$rw->nid->value()]);
          $rw->value()->revision = 0;
          $rw->set($w->value());
        }
        else {
          $rw->value()->revision = 1;
        }

        // Set new revision id before save
        $rw->field_dataset_ref->set($wrapper); /*[LANGUAGE_NONE] = array(array(
          'target_id' => $wrapper->nid->value(),
          'revision_id' => $wrapper->vid->value(),
        ));*/

        //$rw->value()->original = $rw->value();
        $rw->save();
        unset($rw);
      }

      //$wrapper->value()->original = $wrapper->value(); // Nefig mne tut reviziyu menyat'.
      $wrapper->save();
    }
  }
}
function od_dataset_entity_delete($entity, $type) {
  if ($type == 'node' && isset($entity->type) && $entity->type == 'dataset') {
    od_dataset_delete_aliases($entity);
  }
}

function od_dataset_delete_aliases($node_or_nid, $revision_id = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    foreach ($wrapper->{OD_DATASET_DOWNLOAD_FIELD} as $_val_wr) {
      list(, $alias, ) = od_dataset_alias_parse($_val_wr->value());
      path_delete(array('alias' => $alias));
    }
  }
}

function od_dataset_alias_parse($alias) {
  return explode(OD_DATASET_ALIAS_DELIMITER, $alias);
}

function od_dataset_alias_build($type, $alias, $vid) {
  return ($type . OD_DATASET_ALIAS_DELIMITER . $alias . OD_DATASET_ALIAS_DELIMITER . $vid);
}

function od_dataset_last_update_time($node_or_nid, $revision_id = NULL, $type = 'data', $newtime = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $target_date_field = $type == 'data' ? OD_DATASET_FIELD_LATEST_UPDATE_DATASET : OD_DATASET_FIELD_LATEST_UPDATE_STRUCTURE;

    $order = array(
      $target_date_field => array('has_time' => TRUE),
    );

    if ($type == 'data') {
      $order += array(
        'field_date_last_change' => array(),
        'field_date_first_time_publ' => array(),
        'changed' => array('has_time' => TRUE),
      );
    }
    else {
      $order += array(
        'field_date_last_change' => array(),
        'field_date_first_time_publ' => array(),
        'changed' => array('has_time' => TRUE),
      );
    }

    $stamp = NULL;
    foreach ($order as $_fieldname => $_info) {
      if ($stamp = $wrapper->{$_fieldname}->value()) {
        if (empty($_info['has_time']) && ($tmpstamp = $wrapper->changed->value())) {
          $stamp = strtotime(gmdate("H", $tmpstamp). ":". gmdate('i', $tmpstamp). "+00:00", $stamp);
        }
        break;
      }
    }

    // Set time for the first time requesting
    if (!$wrapper->{$target_date_field}->value()) {
      $newtime = $stamp;
    }

    if ($newtime !== NULL) {
      $wrapper->{$target_date_field}->set($newtime);
      //$wrapper->save();
      $stamp = $newtime;
    }

    return $stamp;
  }

  return FALSE;
}


function od_dataset_batch_update_page_callback() {
  $options = array(
    'force' => !empty($_GET['force']),
  );

  $batch = array(
    'operations' => array(
      array('_od_dataset_update_batch_process', array($options)),
    ),
    'title' => t('Updating all aliases for datasets'),
    'init_message' => t('Batch start'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('Batch has encountered an error.'),
    //'file' => drupal_get_path('module', 'batch_example') . '/batch_example.inc',
  );

  batch_set($batch);
  batch_process('node/1');
}

/**
 * Batch processing callback; Generate aliases for nodes.
 */
function _od_dataset_update_batch_process($options, &$context) {
  // Start a transaction
  $transaction = db_transaction();
  try {
    if (!isset($context['sandbox']['current'])) {
      $context['sandbox']['count'] = 0;
      $context['sandbox']['current'] = 0;
      $sql = "
      DELETE
        ua, dp
      FROM {url_alias} AS ua
      INNER JOIN {od_dataset_paths} AS dp ON dp.pid=ua.pid
      WHERE (
        dp.pid IS NOT NULL
      )
      ";

      // Delete orphaned from both tables
      db_query($sql);
    }


    $batch_count = 25;
    $query = db_select('node', 'n');
    $query
      ->fields('n', array('nid'))
      ->condition('n.type', 'dataset');
      //->condition('n.nid', 185);

    // Get the total amount of items to process.
    if (!isset($context['sandbox']['total'])) {
      $context['sandbox']['total'] = $query->countQuery()->execute()->fetchField();

      // If there are no nodes to update, then stop immediately.
      if (!$context['sandbox']['total']) {
        $context['finished'] = 1;
        return;
      }
    }

    $query->range($context['sandbox']['current'], $batch_count);
    $context['sandbox']['current'] += $batch_count;
    foreach (($rows = $query->execute()) as $row) {
      if ($wrapper = od_dataset_get_wrapper($row->nid)) {
        $revs = node_revision_list($wrapper->value());
        foreach (array_reverse($revs) as $rev) {
          $twrp = od_dataset_get_wrapper($wrapper, $rev->vid);
          $fields_to_update = array(
            OD_DATASET_DOWNLOAD_FIELD => array(),
            OD_DATASET_FIELD_LATEST_UPDATE_DATASET => array(),
            OD_DATASET_FIELD_LATEST_UPDATE_STRUCTURE => array(),
          );

          if (empty($options['force'])) {
            // Apply filtering: do not update old nodes if they already have values
            foreach ($fields_to_update as $_fieldname => $_meta) {
              if ($twrp->{$_fieldname}->value()) {
                unset($fields_to_update[$_fieldname]);
              }
            }
          }

          // Only save url aliases for now
          od_dataset_set_alias_links($twrp);
          od_dataset_save_aliases($twrp);

          // Handle real field values
          if (!empty($fields_to_update)) {
            $twrp->value()->revision = 1;
            try {
              od_dataset_save_important_fields($twrp, NULL, $fields_to_update);
              unset($transaction);
            }
            catch (Exception $e) {
              watchdog_exception('od_dataset', $e);
            }
          }
          unset($twrp);
          $twrp = NULL;
        }
      }

      unset($wrapper);
      $wrapper = NULL;
    }

    $context['sandbox']['count'] += $rows->rowCount();
    $context['message'] = t('Updated alias for node @nid.', array('@nid' => $row->nid));

    if ($context['sandbox']['count'] != $context['sandbox']['total']) {
      $context['finished'] = $context['sandbox']['count'] / $context['sandbox']['total'];
    }

    // Commit transaction
    unset($transaction);
  }
  catch (Exception $e) {
    if (isset($transaction)) {
      $transaction->rollback();
    }

    throw $e;
  }
}

class ODDatasetDownloadUriObject extends stdClass {
  /*
   * Constants
   */
  const LINK_EXTERNAL = 'external';
  const LINK_INTERNAL = 'internal';

  /**
   * @var string Main storage of all properties @fixme: Change to another variable
   */
  protected $_properties = array();

  /**
   * Magic converting to string
   * @return string
   */
  public function __toString() {
    return (string) $this->data();
  }

  /**
   * Correctly check if it has valid url.
   * @return bool
   */
  public function exists() {
    return $this->data() !== FALSE && $this->data() !== NULL;
  }

  public function checkReturn() {
    return $this->exists() ? $this : FALSE;
  }

  /**
   * Set/get wrapper for lazy people like me
   * @param $property
   * @param null $value
   * @param null $default
   * @return null
   */
  protected function setGet($property, $value = NULL, $default = NULL) {
    if ($value !== NULL) {
      $this->_properties[$property] = $value;
    }

    return isset($this->_properties[$property]) ? $this->_properties[$property] : $default;
  }

  public function type($type = NULL) {
    return $this->setGet('type', $type);
  }

  public function data($data = NULL) {
    return $this->setGet('link', $data);
  }

  /**
   * Clear all properties and make whole object invalid
   */
  public function invalidate() {
    $this->_properties = array();
  }
}

function od_dataset_entity_load($entities, $type) {
//  try {
//    od_dataset_entity_load_unsafe($entities, $type);
//  }
//  catch (Exception $e) {
//    watchdog_exception('od_dataset_smartagent', $e);
//  }
}

function od_dataset_entity_load_unsafe($entities, $type) {
  static $processed = array();
  if ($type == 'node') {
    foreach ($entities as $entity) {
      if (!isset($processed[$entity->nid])) {
        $processed[$entity->nid] = TRUE;
        $wrapper = od_dataset_get_wrapper($entity);
        switch ($wrapper->getBundle()) {
          case 'dataset':
            if ($wrapper->field_resources->raw()) {
              $newdata = array();
              $to_set_or_not_to_set = FALSE;
              $revs = node_revision_list($entity);
              $rev = reset($revs);
              foreach ($wrapper->field_resources as $iw) {
                if (($item = $iw->raw()) && (!is_array($item) || !isset($item['vid']))) {
                  $vid = db_query('
                  SELECT
                    vid
                  FROM
                    {node_revision} n
                  WHERE
                    n.nid=:nid
                    AND n.timestamp<=:tsend
                   ORDER BY
                    n.timestamp DESC
                   LIMIT 1
                  ', array(
                    ':nid' => $item,
                    ':tsend' => $entity->changed,
                  ))->fetchField();

                  $vid = $vid ? $vid : $iw->vid->value();
                  $newdata[] = array('id' => $item, 'vid' => $vid);
                  $to_set_or_not_to_set = TRUE;

                  $rw = od_dataset_get_wrapper($item, $vid);
                  $rw->field_dataset_ref->set(array('id' => $entity->nid, 'vid' => $entity->vid));
                  od_dataset_save_important_fields($rw, NULL, array('field_dataset_ref' => TRUE));

                  unset($rw);
                  $rw = null;
                }
                elseif ($rev->vid == $entity->vid && ($latest_resource = node_load($item['id'])) && $item['vid'] != $latest_resource->vid) {
                  $newdata[] = array('id' => $item['id'], 'vid' => $latest_resource->vid);
                  $to_set_or_not_to_set = TRUE;

                  $rw = od_dataset_get_wrapper($latest_resource);
                  $rw->field_dataset_ref->set(array('id' => $entity->nid, 'vid' => $entity->vid));
                  od_dataset_save_important_fields($rw, NULL, array('field_dataset_ref' => TRUE));
                }
                else {
                  $newdata[] = $item;
                }
              }

              if ($to_set_or_not_to_set) {
                $wrapper->field_resources->set($newdata);
                od_dataset_save_important_fields($wrapper, NULL, array('field_resources' => TRUE));
                watchdog('od_dataset_smartagent', 'Updated resource revisions for :nid', array(':nid' => $entity->nid));
              }
            }
        }

        unset($wrapper);
        $wrapper = null;
      }
    }
  }
}

/**
 * Creates new revision of a node with new resource revisions
 * @param $node_or_nid
 * @param null $revision_id
 * @return mixed
 */
function od_dataset_revision($node_or_nid, $revision_id = NULL) {
  if ($wrapper = od_dataset_get_wrapper($node_or_nid, $revision_id)) {
    $wrapper->value()->revision = 1;
    // Say that it is a clean revision, permitted to show on passport page
    $wrapper->field_revision_dirty->set(FALSE);
    $wrapper->save();
    //$wrapper = od_dataset_get_wrapper($wrapper->nid->value());
    $new_resources = array();
    foreach ($wrapper->field_resources as $rw) {
      $rw->value()->revision = 1;
      $rw->field_dataset_ref->set($wrapper->value()); // Now points to new dataset revision
      $rw->save();

      $new_resources[] = $rw->value();
    }

    $wrapper->field_resources->set($new_resources);
    $wrapper->value()->revision = 0;
    $wrapper->save();

    return $wrapper->value();
  }
}

/**
 * Clones entityform_types with their field.
 * @param $source_machine_name
 * @param $new_machine_name
 * @param $overwrite_fields
 * @return bool
 */
function od_dataset_clone_ef_type($source_machine_name, $new_machine_name, $overwrite_fields = FALSE) {
  $source = entityform_type_load($source_machine_name);
  if (!$source) {
    return FALSE;
  }

  $ids = entity_extract_ids('entityform_type', $source);
  $entityform = entityform_type_load($new_machine_name);
  if (!$entityform) {
    $entityform = clone $source;
    $entityform->type = $new_machine_name;
    unset($entityform->id);
    $entityform->is_new = TRUE;
    $entityform->label .= '(cloned djedaically)';
    entity_save('entityform_type', $entityform);
  }

  $instances = field_info_instances('entityform', $source->type);
  foreach ($instances as $field_name => $instance) {
    $existing = field_info_instance('entityform', $field_name, $entityform->type);
    if ($overwrite_fields && $existing) {
      field_delete_instance($existing, FALSE);
    }

    if ($overwrite_fields || !$existing) {
      $instance['bundle'] = $entityform->type;
      unset($instance['id']);
      field_create_instance($instance);
    }
  }

  return TRUE;
}