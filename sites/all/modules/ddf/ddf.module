<?php

/**
 * Implements hook_menu().
 */
function ddf_menu() {
  $items = array();

  $items['ddf/update/%/%/%/%'] = array(
    'title' => 'Update dependent widget',
    'page callback' => 'ddf_update_callback',
    'page arguments' => array(2, 3, 4, 5),
    'access callback' => 'ddf_update_access_callback',
    'access arguments' => array(2, 3, 4, 5),
    'type' => MENU_CALLBACK,
    'delivery callback' => 'ajax_deliver',
  );

  return $items;
}

/**
 * Ajax callback returning ajax commands to update dependent widgets.
 */
function ddf_update_callback($controlling_field_name, $entity_type, $bundle, $entity_id) {
  $result = array('#type' => 'ajax', '#commands' => array());
  $dependent_fields = db_select('ddf', 'd')
    ->fields('d', array('dependent_field_name', 'data'))
    ->condition('field_name', $controlling_field_name)
    ->condition('entity_type', $entity_type)
    ->condition('bundle', $bundle)
    ->execute()
    ->fetchAllKeyed();
  if (empty($dependent_fields)) {
    return $result;
  }
  if ($entity_id == 'NULL') {
    $entity_id = NULL;
  }
  $parameters = drupal_get_query_parameters($_GET);
  $entity = NULL;
  if (!is_null($entity_id)) {
    $entity = entity_load_single($entity_type, $entity_id);
  }
  if (empty($entity)) {
    $entity = NULL;
  }

  // Replace '_none' => NULL for select widgets.
  foreach ($parameters as $field_name => $value) {
    if ($value === '_none') {
      $instance = field_info_instance($entity_type, $field_name, $bundle);
      if (($instance) && ($instance['widget']['type'] == 'options_select')) {
        $parameters[$field_name] = NULL;
      }
    }
  }

  foreach ($dependent_fields as $dependent_field_name => $settings) {
    if (!empty($settings)) {
      $settings = unserialize($settings);
    }
    $dependent_field = field_info_field($dependent_field_name);
    if (is_null($dependent_field)) {
      continue;
    }
    $selector = '';
    if (isset($parameters['dep:' . $dependent_field_name])) {
      $selector = $parameters['dep:' . $dependent_field_name];
    }
    $commands = module_invoke_all('ddf_update_widget', $dependent_field, $parameters, $selector, $entity, $settings, $controlling_field_name, $entity_type, $bundle);
    if (empty($commands)) {
      continue;
    }
    $result['#commands'] = array_merge_recursive($result['#commands'], $commands);
  }

  return $result;
}

/**
 * Access callback returning TRUE if the user can edit current entity.
 */
function ddf_update_access_callback($controlling_field_name, $entity_type, $bundle, $entity_id) {
  $dependencies = ddf_load_dependencies($entity_type, $bundle);
  if (empty($dependencies)) {
    return FALSE;
  }

  $exists = FALSE;
  foreach ($dependencies as $dependency) {
    if ($dependency[0] == $controlling_field_name) {
      $exists = TRUE;
      break;
    }
  }
  if (!$exists) {
    return FALSE;
  }

  $field = field_info_field($controlling_field_name);
  $instance = field_info_instance($entity_type, $controlling_field_name, $bundle);
  if (!$field || !$instance || !field_access('edit', $field, $entity_type)) {
    return FALSE;
  }

  // Enable access for unknown entity types.
  $op = TRUE;

  switch ($entity_type) {
    case 'node':
    case 'taxonomy_term':
    case 'user':
      $op = empty($entity) ? 'create' : 'update';
      break;

    case 'comment':
      $op = empty($entity) ? user_access('post comments') : 'edit';
      break;
  }

  if (is_bool($op)) {
    return $op;
  }

  $entity = entity_load_single($entity_type, $entity_id);
  if (empty($entity)) {
    $entity = NULL;
  }

  $result = entity_access($op, $entity_type, $entity);
  if ($result === FALSE) {
    return $result;
  }
  return TRUE;
}

/**
 * Implements hook_field_delete_field().
 */
function ddf_field_delete_field($field) {
  db_delete('ddf')
    ->condition('field_name', $field['field_name'])
    ->execute();

  db_delete('ddf')
    ->condition('dependent_field_name', $field['field_name'])
    ->execute();
}

/**
 * Implements hook_field_delete_instance().
 */
function ddf_field_delete_instance($instance) {
  db_delete('ddf')
    ->condition('field_name', $instance['field_name'])
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();

  db_delete('ddf')
    ->condition('dependent_field_name', $instance['field_name'])
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
}

function ddf_add_dependency($controlling_field_name, $dependent_field_name, $entity_type, $bundle, $settings = NULL) {
  $fields = array(
    'field_name' => $controlling_field_name,
    'entity_type' => $entity_type,
    'bundle' => $bundle,
    'dependent_field_name' => $dependent_field_name,
  );
  if (!is_null($settings)) {
    $fields['data'] = serialize($settings);
  }
  db_insert('ddf')->fields($fields)->execute();
}

function ddf_remove_dependency($dependent_field_name, $entity_type, $bundle) {
  db_delete('ddf')
    ->condition('dependent_field_name', $dependent_field_name)
    ->condition('entity_type', $entity_type)
    ->condition('bundle', $bundle)
    ->execute();
}

/**
 * Loads dependencies from the database.
 */
function ddf_load_dependencies($entity_type, $bundle) {
  // Use the advanced drupal_static() pattern.
  static $dependencies = NULL;
  if (!isset($dependencies)) {
    $dependencies = &drupal_static(__FUNCTION__);
  }

  if (!$dependencies) {
    $dependencies = array();
  }

  if (!isset($dependencies[$entity_type][$bundle])) {
    $dependencies[$entity_type][$bundle] = array();
    $result = db_select('ddf', 'd')
      ->fields('d', array('field_name', 'dependent_field_name'))
      ->condition('entity_type', $entity_type)
      ->condition('bundle', $bundle)
      ->execute();
    foreach ($result as $dependency) {
      $dependencies[$entity_type][$bundle][] = array($dependency->field_name, $dependency->dependent_field_name);
    }
  }

  return $dependencies[$entity_type][$bundle];
}

/**
 * Implements hook_element_info_alter().
 * Adds an #after_build function to all form elements.
 */
function ddf_element_info_alter(&$types) {
  foreach ($types as $type => $info) {
    $types[$type]['#after_build'][] = 'ddf_element_after_build';
  }
}

function ddf_element_after_build($element, &$form_state) {
  // Ensure that the element is a field.
  if (isset($element['#field_name'])) {
    $field = $element;
  }
  elseif (isset($element['#language'], $element[$element['#language']], $element[$element['#language']]['#field_name'])) {
    // Some fields are wrapped in containers before processing.
    $field = $element[$element['#language']];
  }
  else {
    return $element;
  }

  $form = &$form_state['complete form'];

  // Avoid processing fields in fields_ui administration pages.
  if (drupal_substr($form['#form_id'], 0, 9) == 'field_ui_') {
    return $element;
  }

  $entity_type = '';
  $bundle = '';
  $entity = NULL;
  $entity_id = NULL;
  if (isset($field['#entity_type'], $field['#bundle'])) {
    $entity_type = $field['#entity_type'];
    $bundle = $field['#bundle'];
    $entity = $field['#entity'];
  }
  elseif (isset($form['#entity_type'], $form['#bundle'])) {
    $entity_type = $form['#entity_type'];
    $bundle = $form['#bundle'];
    $entity = $form['#entity'];
  }
  else {
    return $element;
  }
  if (!empty($entity)) {
    list($entity_id,,) = entity_extract_ids($entity_type, $entity);
  }
  if (empty($entity_id)) {
    $entity_id = 'NULL';
  }
  $dependencies = ddf_load_dependencies($entity_type, $bundle);
  if (empty($dependencies)) {
    return $element;
  }

  foreach ($dependencies as $dependency) {
    // Process dependent field.
    if ($dependency[1] == $field['#field_name']) {
      $form['#attached']['js'][] = array(
        'type' => 'setting',
        'data' => array(
          'ddf' => array(
            $form['#build_id'] => array(
              'dependent' => array($field['#field_name'] => $field['#name']),
            ),
          ),
        ),
      );
      continue;
    }

    // Process controlling field.
    if ($dependency[0] == $field['#field_name']) {
      if (isset($field['#name'])) {
        $form['#attached']['js'][] = array(
          'type' => 'setting',
          'data' => array(
            'ddf' => array(
              $form['#build_id'] => array(
                'entity_type' => $entity_type,
                'bundle' => $bundle,
                'entity_id' => $entity_id,
                'fields' => array($field['#field_name'] => $field['#name']),
              ),
            ),
          ),
        );
        drupal_add_library('system', 'drupal.ajax');
        drupal_add_library('system', 'jquery.form');
        $form['#attached']['js'][] = drupal_get_path('module', 'ddf') . '/ddf.js';
      }
    }
  }
  return $element;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 */
function ddf_field_widget_options_select_form_alter(&$element, &$form_state, $context) {
  // Fix dependent fields with selects which loose multiple property for empty lists, see options_field_widget_form() function in options.module file.
  $dependencies = ddf_load_dependencies($context['instance']['entity_type'], $context['instance']['bundle']);
  if (empty($dependencies)) {
    return;
  }
  $field = $context['field'];
  foreach ($dependencies as $dependency) {
    if ($dependency[1] == $field['field_name']) {
      if ((isset($element['#multiple'])) && (!$element['#multiple'])) {
        $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
        if ($multiple) {
          $element['#multiple'] = TRUE;
        }
      }
    }
  }
}
